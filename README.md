# JUC
## 锁相关
> 公平锁

多个线程按照申请锁的顺序来获取锁；在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果队列为空或者当前线程是等待队列的第一个节点，当前线程就占有锁，否则就会加入等待队列中，然后按照FIFO的规则等待出队获取锁。
> 非公平锁

多个线程获取所得顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象。非公平锁会直接尝试获取锁，如果尝试失败，就再采用类似公平锁的方式获取锁。非公平锁的优点在于吞吐量比公平锁大。
ReentrantLock可以实现公平锁和非公平锁，默认实现非公平锁，可以通过构造函数传参true实现公平锁。
可以看到使用非公平锁，底层lock方法时，会先调用compareAndSetState尝试获得锁，失败了，才调用acquire方法尝试获取锁，这就是非公平的体现。
> 可重入锁和递归锁 防止死锁

> 自旋锁

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去不断尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

> 读（共享锁）写（独占）锁/互斥锁

多个线程同时读一个共享资源是允许的，但是同一时刻只允许有一个线程来修改（写）共享资源。即读读可同时进行，读写可同时进行，写写必须加锁。
